# rubyによるデザインパターン

## rubyによるデザインパターンの考え方とパターンごとの実装例をまとめたものです

### パターンのためのパターン
- 変わるものを変わらないものから分離する
- インターフェイスに対してプログラムし、実装に対して行わない
- 継承より集約
- 委譲、委譲、委譲  
etc.
- 必要になるまで作るな

#### 変わるものを変わらないものから分離する
理想的なシステムでは、すべての変更は局所的。  
つまり、Aの変更がBの変更を必要としたり、それが元でCの変更を伴ったり、結局その影響がZまで及ばないようにすべき。  
そのためには、変わりやすいと思われるものを変わりにくいと思われるものから分離する。

#### インターフェイスに対してプログラムし、実装に対して行わない
可能な限り一般的な型に対してプログラミングする。仮に自動車や飛行機を扱う必要がある場合は、自動車を乗り物と呼べるなら自動車と呼ばない。  
つまり、すべての重要な機能をたくさんのインターフェイスに注意深く抽象化し、クラスはそれを実装するということ。  
すなわち、自動車をさらに何かより一般的なもの、たとえば「可動オブジェクト」として出せればよい。  
とはいえ、インターフェイスに対するプログラミングだけが、コードを変更に対して強くする唯一の方法ではなく、集約もその一つ

#### 継承より集約
継承を使えば、コストをかけずに実装を手に入れられることができるが、望ましくないつながりを作ってしまう問題点があります。  
既存のあるクラスのサブクラスを作るとき、それは本当に別々の2つの実体を作っているのではなく、共通の実装部分で結びつけられた2つのクラスを作っている。  
継承は、まさにその性質から、サブクラスをスーパークラスに結びつける傾向がある。  
私たちの目標が、それぞれが強く結合されていないシステムを、そして1つの変更が衝撃波のように伝わらないように構築することであれば、おそらく今しているほど継承に頼るべきではない。  

その代わりに私たちが必要とする振る舞いは、集約を使って実現することができる。  
スーパークラスから多くの機能を継承するクラスを作る代わりに、ボトムアップに機能を集めることができる。  
オブジェクトに他のオブジェクト、すなわち必要とする機能を持ったオブジェクトの参照を持たせる。  
要するに、オブジェクトが何かの一種である(is-a-kind-of)関係は避けて、何かを持っている(has-a)関係にするということ。

例) 自動車  

```
class Vehicle
  # 乗り物に関するコード

  def start_engine
    # エンジンをスタート
  end

  def stop_engine
    # エンジンをストップ
  end
end

class Car < Vehicle
  def sunday_drive
    start_engine
    # 地方に出かけ、戻ってきます
    stop_engine
  end
end
```
このコードの背後にある考えは、  
自動車はエンジンのスタートとストップをする必要があるが、それは他の多くの乗り物にとっても同様のため、エンジンに関するコードを共通の基底クラスである`Vehicle`として抽象化した。  
これは、すべての乗り物がエンジンを持っていることが必要です。もしエンジンのない乗り物(自転車やヨット)を扱うとなると、これらのクラスに大改造を施さなければならない。  
結局、エンジンは`Vehicle`に管理されていて、`Car`は`Vehicle`の一種であるというだけで、これでは、変わりやすい部分を変わりにくい部分から分離できていない。  
これらの問題を解決するためには、エンジンに関するコードを`Car`のスーパークラスの中に作るのではなく、完全なスタンドアローンなクラスとして作る。
```
class Engine
  # エンジンに関するコード

  def start
    # エンジンをスタート
  end

  def stop
    # エンジンをストップ
  end

end
```

そして、`Car`オブジェクトにそれぞれ`Engine`の参照を与えさえすれば、集約のおかげでドライブの準備が整ったことになる。
```
class Car
  def initialize
    @engine = Engine.new
  end

  def sunday_drive
    @engine.start
    # 地方にお出かけし、戻ってきます
    @engine.stop
  end
end
```
集約を使って機能を組み立てることで、多くの利点を得ることができる。  
まず、エンジンに関するコードが、エンジンという本来のクラスの中に移動したので、再利用性が高まる。  
さらに、`vehicle`からエンジンに関するコードを取り出すことによって、`vehicle`クラスをシンプルにできた。  
また、カプセル化も促進しており、`vehicle`からエンジンに関するコードを分離したことで、自動車とエンジンの間にインターフェイスの厚い壁ができた。  
また、他の種類のエンジンを利用できる可能性もあり、`Engine`クラスを抽象的な型にし、様々なエンジンを作って自動車から利用するようにもできる。  
```
class Car
  def initialize
    @engine = GasolineEngine.new
  end

  def sunday_drive
    @engine.start
    # 地方にお出かけし、もどってきます。
    @engine.stop
  end

  def switch_to_diesel
    @engine = DiselEngine.new
  end
end
```


#### 委譲、委譲、委譲
何者かが`car`の`start_engine`メソッドを呼ぶと、`car`オブジェクトは「私の担当じゃない」と言って、バトンをエンジンに手渡す。  
この「責任転嫁」のテクニックには、「委譲(delegation)」という、名前がついている。  
集約と委譲の組み合わせは、継承に対するとても強力で柔軟な代替手段である。  

#### 必要になるまで作るな
この設計原則は,XP界隈からでてきたもので、「You Ain't Gonna Need It」(必要になるまで作るな)と的確な表現で要約されるもの。  
YAGNI原則を簡単に説明すると、今まさに必要としていない機能や設計の柔軟性を実装すべきでない、というもの。  
それは、「後で必要にならない」可能性も、同じようにあるから。  
今必要かどうかわからなければ、本当に必要になるまでその機能を実装しない。もし今必要としていないのなら、今は実装せずに、その代わりに今確実に必要としているものの実装に時間とエネルギーを使うべきだから。  
そしてまた、本当に必要になるまで待てれば、何が必要で、どのようにすべきかのよりよい理解を持ちやすくなっているはずです。

デザインパターンの適切な使い方は、今日あなたが持っている問題に対応できるだけの柔軟性をシステムに組み込むことで、それ以上ではありません。
